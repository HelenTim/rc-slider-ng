{
    "sourceFile": "src/Slider.tsx",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 27,
            "patches": [
                {
                    "date": 1678428793971,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1678428876886,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -282,18 +282,24 @@\n     if (!disabled) {\n       let valueIndex = 0;\n       let valueDist = mergedMax - mergedMin;\n \n+      \n+\n       if (!disableds.includes(true)) { \n         rawValues.forEach((val, index) => {\n         const dist = Math.abs(newValue - val);\n-        if (dist <= valueDist) {\n-          valueDist = dist;\n-          valueIndex = index;\n-        }\n+          if (dist <= valueDist) {\n+            valueDist = dist;\n+            valueIndex = index;\n+          }\n         });\n       }\n \n+\n+\n+\n+\n       \n \n       // Create new values\n       const cloneNextValues = [...rawValues];\n"
                },
                {
                    "date": 1678428987921,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -282,11 +282,11 @@\n     if (!disabled) {\n       let valueIndex = 0;\n       let valueDist = mergedMax - mergedMin;\n \n-      \n+      let disabledsTrueIndex = disableds.findIndex((item) => item === true);\n \n-      if (!disableds.includes(true)) { \n+      if (disabledsTrueIndex === -1) { \n         rawValues.forEach((val, index) => {\n         const dist = Math.abs(newValue - val);\n           if (dist <= valueDist) {\n             valueDist = dist;\n"
                },
                {
                    "date": 1678428996957,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -284,16 +284,18 @@\n       let valueDist = mergedMax - mergedMin;\n \n       let disabledsTrueIndex = disableds.findIndex((item) => item === true);\n \n-      if (disabledsTrueIndex === -1) { \n+      if (disabledsTrueIndex === -1) {\n         rawValues.forEach((val, index) => {\n-        const dist = Math.abs(newValue - val);\n+          const dist = Math.abs(newValue - val);\n           if (dist <= valueDist) {\n             valueDist = dist;\n             valueIndex = index;\n           }\n         });\n+      } else { \n+        \n       }\n \n \n \n"
                },
                {
                    "date": 1678429196743,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -293,9 +293,11 @@\n             valueIndex = index;\n           }\n         });\n       } else { \n-        \n+        if (disabledsTrueIndex == 0) { \n+          \n+        }\n       }\n \n \n \n"
                },
                {
                    "date": 1678429352016,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -281,8 +281,9 @@\n   const changeToCloseValue = (newValue: number) => {\n     if (!disabled) {\n       let valueIndex = 0;\n       let valueDist = mergedMax - mergedMin;\n+      debugger;\n \n       let disabledsTrueIndex = disableds.findIndex((item) => item === true);\n \n       if (disabledsTrueIndex === -1) {\n@@ -294,9 +295,9 @@\n           }\n         });\n       } else { \n         if (disabledsTrueIndex == 0) { \n-          \n+\n         }\n       }\n \n \n"
                },
                {
                    "date": 1678429739785,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -281,9 +281,9 @@\n   const changeToCloseValue = (newValue: number) => {\n     if (!disabled) {\n       let valueIndex = 0;\n       let valueDist = mergedMax - mergedMin;\n-      debugger;\n+      // debugger;\n \n       let disabledsTrueIndex = disableds.findIndex((item) => item === true);\n \n       if (disabledsTrueIndex === -1) {\n"
                },
                {
                    "date": 1678429790070,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -281,9 +281,9 @@\n   const changeToCloseValue = (newValue: number) => {\n     if (!disabled) {\n       let valueIndex = 0;\n       let valueDist = mergedMax - mergedMin;\n-      // debugger;\n+      debugger;\n \n       let disabledsTrueIndex = disableds.findIndex((item) => item === true);\n \n       if (disabledsTrueIndex === -1) {\n"
                },
                {
                    "date": 1678430236928,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -294,10 +294,10 @@\n             valueIndex = index;\n           }\n         });\n       } else { \n-        if (disabledsTrueIndex == 0) { \n-\n+        if (disabledsTrueIndex == 0 && newValue>rawValues[0]) { \n+            \n         }\n       }\n \n \n"
                },
                {
                    "date": 1678430276443,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -285,9 +285,9 @@\n       debugger;\n \n       let disabledsTrueIndex = disableds.findIndex((item) => item === true);\n \n-      if (disabledsTrueIndex === -1) {\n+      if (disabledsTrueIndex === -1 || allowCross === false) {\n         rawValues.forEach((val, index) => {\n           const dist = Math.abs(newValue - val);\n           if (dist <= valueDist) {\n             valueDist = dist;\n@@ -295,9 +295,9 @@\n           }\n         });\n       } else { \n         if (disabledsTrueIndex == 0 && newValue>rawValues[0]) { \n-            \n+\n         }\n       }\n \n \n"
                },
                {
                    "date": 1678430880407,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -281,23 +281,25 @@\n   const changeToCloseValue = (newValue: number) => {\n     if (!disabled) {\n       let valueIndex = 0;\n       let valueDist = mergedMax - mergedMin;\n-      debugger;\n+      // debugger;\n \n       let disabledsTrueIndex = disableds.findIndex((item) => item === true);\n \n-      if (disabledsTrueIndex === -1 || allowCross === false) {\n+      if (disabledsTrueIndex === -1) {\n         rawValues.forEach((val, index) => {\n           const dist = Math.abs(newValue - val);\n           if (dist <= valueDist) {\n             valueDist = dist;\n             valueIndex = index;\n           }\n         });\n       } else { \n-        if (disabledsTrueIndex == 0 && newValue>rawValues[0]) { \n-\n+        if (newValue > rawValues[disabledsTrueIndex]) {\n+          valueIndex = disabledsTrueIndex + 1;\n+        } else { \n+          return;\n         }\n       }\n \n \n"
                },
                {
                    "date": 1678431108031,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -285,23 +285,26 @@\n       // debugger;\n \n       let disabledsTrueIndex = disableds.findIndex((item) => item === true);\n \n-      if (disabledsTrueIndex === -1) {\n+       if(disabledsTrueIndex !== -1) { \n+        if (newValue > rawValues[disabledsTrueIndex]) {\n+          valueIndex = disabledsTrueIndex + 1;\n+        } else { \n+          return;\n+        }\n+       } else {\n+         \n         rawValues.forEach((val, index) => {\n           const dist = Math.abs(newValue - val);\n           if (dist <= valueDist) {\n             valueDist = dist;\n             valueIndex = index;\n           }\n         });\n-      } else { \n-        if (newValue > rawValues[disabledsTrueIndex]) {\n-          valueIndex = disabledsTrueIndex + 1;\n-        } else { \n-          return;\n-        }\n-      }\n+      \n+       }\n+    \n \n \n \n \n"
                },
                {
                    "date": 1678431280992,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -285,26 +285,23 @@\n       // debugger;\n \n       let disabledsTrueIndex = disableds.findIndex((item) => item === true);\n \n-       if(disabledsTrueIndex !== -1) { \n-        if (newValue > rawValues[disabledsTrueIndex]) {\n-          valueIndex = disabledsTrueIndex + 1;\n-        } else { \n-          return;\n-        }\n-       } else {\n-         \n+      if (disabledsTrueIndex === -1) {\n         rawValues.forEach((val, index) => {\n           const dist = Math.abs(newValue - val);\n           if (dist <= valueDist) {\n             valueDist = dist;\n             valueIndex = index;\n           }\n         });\n-      \n-       }\n-    \n+      }else  { \n+        if (newValue > rawValues[disabledsTrueIndex]) {\n+          valueIndex = disabledsTrueIndex + 1;\n+        } else { \n+          valueIndex = disabledsTrueIndex - 1;\n+        }\n+      }\n \n \n \n \n"
                },
                {
                    "date": 1678431503573,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -295,9 +295,18 @@\n           }\n         });\n       }else  { \n         if (newValue > rawValues[disabledsTrueIndex]) {\n-          valueIndex = disabledsTrueIndex + 1;\n+          rawValues.forEach((val, index) => {\n+            const dist = Math.abs(newValue - val);\n+            if (index > disabledsTrueIndex) { \n+              if (dist <= valueDist) {\n+            valueDist = dist;\n+            valueIndex = index;\n+          }\n+            }\n+          \n+        });\n         } else { \n           valueIndex = disabledsTrueIndex - 1;\n         }\n       }\n"
                },
                {
                    "date": 1678432820391,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -293,31 +293,42 @@\n             valueDist = dist;\n             valueIndex = index;\n           }\n         });\n-      }else  { \n+      } else {\n         if (newValue > rawValues[disabledsTrueIndex]) {\n+          let hasResault = false;\n           rawValues.forEach((val, index) => {\n             const dist = Math.abs(newValue - val);\n-            if (index > disabledsTrueIndex) { \n+            if (index > disabledsTrueIndex) {\n               if (dist <= valueDist) {\n-            valueDist = dist;\n-            valueIndex = index;\n+                valueDist = dist;\n+                valueIndex = index;\n+                hasResault = true;\n+              }\n+            }\n+          });\n+          if (!hasResault) { \n+            return;\n           }\n+        } else {\n+          let hasResault = false;\n+          rawValues.forEach((val, index) => {\n+            const dist = Math.abs(newValue - val);\n+            if (index < disabledsTrueIndex) {\n+              if (dist <= valueDist) {\n+                valueDist = dist;\n+                valueIndex = index;\n+                hasResault = true;\n+              }\n             }\n-          \n-        });\n-        } else { \n-          valueIndex = disabledsTrueIndex - 1;\n+          });\n+          if (!hasResault) { \n+            return;\n+          }\n         }\n       }\n \n-\n-\n-\n-\n-      \n-\n       // Create new values\n       const cloneNextValues = [...rawValues];\n \n       cloneNextValues[valueIndex] = newValue;\n@@ -336,10 +347,16 @@\n   // ============================ Click =============================\n   const onSliderMouseDown: React.MouseEventHandler<HTMLDivElement> = (e) => {\n     e.preventDefault();\n \n-    const { width, height, left, top, bottom, right } =\n-      containerRef.current.getBoundingClientRect();\n+    const {\n+      width,\n+      height,\n+      left,\n+      top,\n+      bottom,\n+      right,\n+    } = containerRef.current.getBoundingClientRect();\n     const { clientX, clientY } = e;\n \n     let percent: number;\n     switch (direction) {\n@@ -432,12 +449,11 @@\n     }\n   }, [dragging]);\n \n   // =========================== Included ===========================\n-  const sortedCacheValues = React.useMemo(\n-    () => [...cacheValues].sort((a, b) => a - b),\n-    [cacheValues],\n-  );\n+  const sortedCacheValues = React.useMemo(() => [...cacheValues].sort((a, b) => a - b), [\n+    cacheValues,\n+  ]);\n \n   // Provide a range values with included [min, max]\n   // Used for Track, Mark & Dot\n   const [includedStart, includedEnd] = React.useMemo(() => {\n"
                },
                {
                    "date": 1678434507410,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -277,9 +277,10 @@\n     // We set this later since it will re-render component immediately\n     setValue(cloneNextValues);\n   };\n \n-  const changeToCloseValue = (newValue: number) => {\n+  const changeToCloseValue = (newValue: number, e?: any) => {\n+    console.log({e})\n     if (!disabled) {\n       let valueIndex = 0;\n       let valueDist = mergedMax - mergedMin;\n       // debugger;\n@@ -306,9 +307,9 @@\n                 hasResault = true;\n               }\n             }\n           });\n-          if (!hasResault) { \n+          if (!hasResault) {\n             return;\n           }\n         } else {\n           let hasResault = false;\n@@ -321,9 +322,9 @@\n                 hasResault = true;\n               }\n             }\n           });\n-          if (!hasResault) { \n+          if (!hasResault) {\n             return;\n           }\n         }\n       }\n@@ -376,9 +377,9 @@\n         percent = (clientX - left) / width;\n     }\n \n     const nextValue = mergedMin + percent * (mergedMax - mergedMin);\n-    changeToCloseValue(formatValue(nextValue));\n+    changeToCloseValue(formatValue(nextValue),e);\n   };\n \n   // =========================== Keyboard ===========================\n   const [keyboardValue, setKeyboardValue] = React.useState<number>(null);\n"
                },
                {
                    "date": 1678434600622,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -277,10 +277,9 @@\n     // We set this later since it will re-render component immediately\n     setValue(cloneNextValues);\n   };\n \n-  const changeToCloseValue = (newValue: number, e?: any) => {\n-    console.log({e})\n+  const changeToCloseValue = (newValue: number) => {\n     if (!disabled) {\n       let valueIndex = 0;\n       let valueDist = mergedMax - mergedMin;\n       // debugger;\n@@ -377,9 +376,9 @@\n         percent = (clientX - left) / width;\n     }\n \n     const nextValue = mergedMin + percent * (mergedMax - mergedMin);\n-    changeToCloseValue(formatValue(nextValue),e);\n+    changeToCloseValue(formatValue(nextValue));\n   };\n \n   // =========================== Keyboard ===========================\n   const [keyboardValue, setKeyboardValue] = React.useState<number>(null);\n"
                },
                {
                    "date": 1678434707788,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -278,8 +278,9 @@\n     setValue(cloneNextValues);\n   };\n \n   const changeToCloseValue = (newValue: number) => {\n+    console.log({newValue})\n     if (!disabled) {\n       let valueIndex = 0;\n       let valueDist = mergedMax - mergedMin;\n       // debugger;\n"
                },
                {
                    "date": 1678434767652,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -278,9 +278,8 @@\n     setValue(cloneNextValues);\n   };\n \n   const changeToCloseValue = (newValue: number) => {\n-    console.log({newValue})\n     if (!disabled) {\n       let valueIndex = 0;\n       let valueDist = mergedMax - mergedMin;\n       // debugger;\n@@ -346,8 +345,9 @@\n   };\n \n   // ============================ Click =============================\n   const onSliderMouseDown: React.MouseEventHandler<HTMLDivElement> = (e) => {\n+    console.log({e})\n     e.preventDefault();\n \n     const {\n       width,\n"
                },
                {
                    "date": 1678434826258,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -345,9 +345,8 @@\n   };\n \n   // ============================ Click =============================\n   const onSliderMouseDown: React.MouseEventHandler<HTMLDivElement> = (e) => {\n-    console.log({e})\n     e.preventDefault();\n \n     const {\n       width,\n"
                },
                {
                    "date": 1678672199854,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -283,9 +283,9 @@\n       let valueIndex = 0;\n       let valueDist = mergedMax - mergedMin;\n       // debugger;\n \n-      let disabledsTrueIndex = disableds.findIndex((item) => item === true);\n+      const disabledsTrueIndex = disableds.findIndex((item) => item === true);\n \n       if (disabledsTrueIndex === -1) {\n         rawValues.forEach((val, index) => {\n           const dist = Math.abs(newValue - val);\n@@ -293,9 +293,12 @@\n             valueDist = dist;\n             valueIndex = index;\n           }\n         });\n-      } else {\n+      }\n+      \n+      \n+      \n         if (newValue > rawValues[disabledsTrueIndex]) {\n           let hasResault = false;\n           rawValues.forEach((val, index) => {\n             const dist = Math.abs(newValue - val);\n@@ -325,9 +328,9 @@\n           if (!hasResault) {\n             return;\n           }\n         }\n-      }\n+      \n \n       // Create new values\n       const cloneNextValues = [...rawValues];\n \n@@ -347,16 +350,10 @@\n   // ============================ Click =============================\n   const onSliderMouseDown: React.MouseEventHandler<HTMLDivElement> = (e) => {\n     e.preventDefault();\n \n-    const {\n-      width,\n-      height,\n-      left,\n-      top,\n-      bottom,\n-      right,\n-    } = containerRef.current.getBoundingClientRect();\n+    const { width, height, left, top, bottom, right } =\n+      containerRef.current.getBoundingClientRect();\n     const { clientX, clientY } = e;\n \n     let percent: number;\n     switch (direction) {\n@@ -449,11 +446,12 @@\n     }\n   }, [dragging]);\n \n   // =========================== Included ===========================\n-  const sortedCacheValues = React.useMemo(() => [...cacheValues].sort((a, b) => a - b), [\n-    cacheValues,\n-  ]);\n+  const sortedCacheValues = React.useMemo(\n+    () => [...cacheValues].sort((a, b) => a - b),\n+    [cacheValues],\n+  );\n \n   // Provide a range values with included [min, max]\n   // Used for Track, Mark & Dot\n   const [includedStart, includedEnd] = React.useMemo(() => {\n"
                },
                {
                    "date": 1678672331840,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -290,12 +290,14 @@\n         rawValues.forEach((val, index) => {\n           const dist = Math.abs(newValue - val);\n           if (dist <= valueDist) {\n             valueDist = dist;\n-            valueIndex = index;\n+            valueIndex = index;   // 找到距离最近可调节的值下标\n           }\n         });\n       }\n+\n+\n       \n       \n       \n         if (newValue > rawValues[disabledsTrueIndex]) {\n"
                },
                {
                    "date": 1678672970258,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -97,9 +97,9 @@\n }\n \n const Slider = React.forwardRef((props: SliderProps, ref: React.Ref<SliderRef>) => {\n   const {\n-    disableds = [false, false],\n+    disableds = [],\n     prefixCls = 'rc-slider',\n     className,\n     style,\n \n@@ -299,27 +299,26 @@\n \n       \n       \n       \n-        if (newValue > rawValues[disabledsTrueIndex]) {\n+      if (newValue > rawValues[valueIndex] && disableds[valueIndex] === true) {\n+        if (valueIndex + 1 <= rawValues.length - 1) {\n+          ++valueIndex;\n+        } else { \n+          return;\n+        }\n+          \n+      }\n+        \n+        \n+        \n+        \n+        \n+        \n+        else {\n           let hasResault = false;\n           rawValues.forEach((val, index) => {\n             const dist = Math.abs(newValue - val);\n-            if (index > disabledsTrueIndex) {\n-              if (dist <= valueDist) {\n-                valueDist = dist;\n-                valueIndex = index;\n-                hasResault = true;\n-              }\n-            }\n-          });\n-          if (!hasResault) {\n-            return;\n-          }\n-        } else {\n-          let hasResault = false;\n-          rawValues.forEach((val, index) => {\n-            const dist = Math.abs(newValue - val);\n             if (index < disabledsTrueIndex) {\n               if (dist <= valueDist) {\n                 valueDist = dist;\n                 valueIndex = index;\n"
                },
                {
                    "date": 1678672991136,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -305,9 +305,8 @@\n           ++valueIndex;\n         } else { \n           return;\n         }\n-          \n       }\n         \n         \n         \n"
                },
                {
                    "date": 1678673109018,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -300,36 +300,28 @@\n       \n       \n       \n       if (newValue > rawValues[valueIndex] && disableds[valueIndex] === true) {\n-        if (valueIndex + 1 <= rawValues.length - 1) {\n+        if (valueIndex + 1 <= rawValues.length - 1 && disableds[valueIndex+1] !== true) {\n           ++valueIndex;\n         } else { \n           return;\n         }\n       }\n+\n+       if (newValue < rawValues[valueIndex] && disableds[valueIndex] === true) {\n+        if (valueIndex - 1 >=0 && disableds[valueIndex-1] !== true) {\n+          -- valueIndex;\n+        } else { \n+          return;\n+        }\n+      }\n         \n         \n         \n         \n         \n-        \n-        else {\n-          let hasResault = false;\n-          rawValues.forEach((val, index) => {\n-            const dist = Math.abs(newValue - val);\n-            if (index < disabledsTrueIndex) {\n-              if (dist <= valueDist) {\n-                valueDist = dist;\n-                valueIndex = index;\n-                hasResault = true;\n-              }\n-            }\n-          });\n-          if (!hasResault) {\n-            return;\n-          }\n-        }\n+    \n       \n \n       // Create new values\n       const cloneNextValues = [...rawValues];\n"
                },
                {
                    "date": 1678673124089,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -295,12 +295,8 @@\n           }\n         });\n       }\n \n-\n-      \n-      \n-      \n       if (newValue > rawValues[valueIndex] && disableds[valueIndex] === true) {\n         if (valueIndex + 1 <= rawValues.length - 1 && disableds[valueIndex+1] !== true) {\n           ++valueIndex;\n         } else { \n@@ -315,15 +311,8 @@\n           return;\n         }\n       }\n         \n-        \n-        \n-        \n-        \n-    \n-      \n-\n       // Create new values\n       const cloneNextValues = [...rawValues];\n \n       cloneNextValues[valueIndex] = newValue;\n"
                },
                {
                    "date": 1678673226533,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -285,34 +285,34 @@\n       // debugger;\n \n       const disabledsTrueIndex = disableds.findIndex((item) => item === true);\n \n-      if (disabledsTrueIndex === -1) {\n+      if (!disabled) {\n         rawValues.forEach((val, index) => {\n           const dist = Math.abs(newValue - val);\n           if (dist <= valueDist) {\n             valueDist = dist;\n-            valueIndex = index;   // 找到距离最近可调节的值下标\n+            valueIndex = index; // 找到距离最近可调节的值下标\n           }\n         });\n       }\n \n       if (newValue > rawValues[valueIndex] && disableds[valueIndex] === true) {\n-        if (valueIndex + 1 <= rawValues.length - 1 && disableds[valueIndex+1] !== true) {\n+        if (valueIndex + 1 <= rawValues.length - 1 && disableds[valueIndex + 1] !== true) {\n           ++valueIndex;\n-        } else { \n+        } else {\n           return;\n         }\n       }\n \n-       if (newValue < rawValues[valueIndex] && disableds[valueIndex] === true) {\n-        if (valueIndex - 1 >=0 && disableds[valueIndex-1] !== true) {\n-          -- valueIndex;\n-        } else { \n+      if (newValue < rawValues[valueIndex] && disableds[valueIndex] === true) {\n+        if (valueIndex - 1 >= 0 && disableds[valueIndex - 1] !== true) {\n+          --valueIndex;\n+        } else {\n           return;\n         }\n       }\n-        \n+\n       // Create new values\n       const cloneNextValues = [...rawValues];\n \n       cloneNextValues[valueIndex] = newValue;\n@@ -331,10 +331,16 @@\n   // ============================ Click =============================\n   const onSliderMouseDown: React.MouseEventHandler<HTMLDivElement> = (e) => {\n     e.preventDefault();\n \n-    const { width, height, left, top, bottom, right } =\n-      containerRef.current.getBoundingClientRect();\n+    const {\n+      width,\n+      height,\n+      left,\n+      top,\n+      bottom,\n+      right,\n+    } = containerRef.current.getBoundingClientRect();\n     const { clientX, clientY } = e;\n \n     let percent: number;\n     switch (direction) {\n@@ -427,12 +433,11 @@\n     }\n   }, [dragging]);\n \n   // =========================== Included ===========================\n-  const sortedCacheValues = React.useMemo(\n-    () => [...cacheValues].sort((a, b) => a - b),\n-    [cacheValues],\n-  );\n+  const sortedCacheValues = React.useMemo(() => [...cacheValues].sort((a, b) => a - b), [\n+    cacheValues,\n+  ]);\n \n   // Provide a range values with included [min, max]\n   // Used for Track, Mark & Dot\n   const [includedStart, includedEnd] = React.useMemo(() => {\n"
                },
                {
                    "date": 1678673409185,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -283,20 +283,16 @@\n       let valueIndex = 0;\n       let valueDist = mergedMax - mergedMin;\n       // debugger;\n \n-      const disabledsTrueIndex = disableds.findIndex((item) => item === true);\n-\n-      if (!disabled) {\n         rawValues.forEach((val, index) => {\n           const dist = Math.abs(newValue - val);\n           if (dist <= valueDist) {\n             valueDist = dist;\n             valueIndex = index; // 找到距离最近可调节的值下标\n           }\n         });\n-      }\n-\n+      \n       if (newValue > rawValues[valueIndex] && disableds[valueIndex] === true) {\n         if (valueIndex + 1 <= rawValues.length - 1 && disableds[valueIndex + 1] !== true) {\n           ++valueIndex;\n         } else {\n"
                }
            ],
            "date": 1678428793971,
            "name": "Commit-0",
            "content": "import * as React from 'react';\nimport classNames from 'classnames';\nimport isEqual from 'rc-util/lib/isEqual';\nimport useMergedState from 'rc-util/lib/hooks/useMergedState';\nimport type { HandlesRef } from './Handles';\nimport Handles from './Handles';\nimport type { HandlesProps } from './Handles';\nimport useDrag from './hooks/useDrag';\nimport SliderContext from './context';\nimport type { SliderContextProps } from './context';\nimport Tracks from './Tracks';\nimport type { AriaValueFormat, Direction, OnStartMove } from './interface';\nimport Marks from './Marks';\nimport type { MarkObj } from './Marks';\nimport type { InternalMarkObj } from './Marks';\nimport Steps from './Steps';\nimport useOffset from './hooks/useOffset';\nimport warning from 'rc-util/lib/warning';\n\n/**\n * New:\n * - click mark to update range value\n * - handleRender\n * - Fix handle with count not correct\n * - Fix pushable not work in some case\n * - No more FindDOMNode\n * - Move all position related style into inline style\n * - Key: up is plus, down is minus\n * - fix Key with step = null not align with marks\n * - Change range should not trigger onChange\n * - keyboard support pushable\n */\n\nexport interface SliderProps<ValueType = number | number[]> {\n  prefixCls?: string;\n  className?: string;\n  style?: React.CSSProperties;\n\n  // Status\n  disabled?: boolean;\n  keyboard?: boolean;\n  autoFocus?: boolean;\n  onFocus?: (e: React.FocusEvent<HTMLDivElement>) => void;\n  onBlur?: (e: React.FocusEvent<HTMLDivElement>) => void;\n\n  // Value\n  range?: boolean;\n  count?: number;\n  min?: number;\n  max?: number;\n  step?: number | null;\n  value?: ValueType;\n  defaultValue?: ValueType;\n  onChange?: (value: ValueType) => void;\n  /** @deprecated It's always better to use `onChange` instead */\n  onBeforeChange?: (value: ValueType) => void;\n  /** @deprecated It's always better to use `onChange` instead */\n  onAfterChange?: (value: ValueType) => void;\n\n  // Cross\n  allowCross?: boolean;\n  pushable?: boolean | number;\n  /** range only */\n  draggableTrack?: boolean;\n\n  // Direction\n  reverse?: boolean;\n  vertical?: boolean;\n\n  // Style\n  included?: boolean;\n  startPoint?: number;\n  trackStyle?: React.CSSProperties | React.CSSProperties[];\n  handleStyle?: React.CSSProperties | React.CSSProperties[];\n  railStyle?: React.CSSProperties;\n  dotStyle?: React.CSSProperties | ((dotValue: number) => React.CSSProperties);\n  activeDotStyle?: React.CSSProperties | ((dotValue: number) => React.CSSProperties);\n\n  // Decorations\n  marks?: Record<string | number, React.ReactNode | MarkObj>;\n  dots?: boolean;\n\n  // Components\n  handleRender?: HandlesProps['handleRender'];\n\n  // Accessibility\n  tabIndex?: number | number[];\n  ariaLabelForHandle?: string | string[];\n  ariaLabelledByForHandle?: string | string[];\n  ariaValueTextFormatterForHandle?: AriaValueFormat | AriaValueFormat[];\n  disableds?: boolean[];\n}\n\nexport interface SliderRef {\n  focus: () => void;\n  blur: () => void;\n}\n\nconst Slider = React.forwardRef((props: SliderProps, ref: React.Ref<SliderRef>) => {\n  const {\n    disableds = [false, false],\n    prefixCls = 'rc-slider',\n    className,\n    style,\n\n    // Status\n    disabled = false,\n    keyboard = true,\n    autoFocus,\n    onFocus,\n    onBlur,\n\n    // Value\n    min = 0,\n    max = 100,\n    step = 1,\n    value,\n    defaultValue,\n    range,\n    count,\n    onChange,\n    onBeforeChange,\n    onAfterChange,\n\n    // Cross\n    allowCross = true,\n    pushable = false,\n    draggableTrack,\n\n    // Direction\n    reverse,\n    vertical,\n\n    // Style\n    included = true,\n    startPoint,\n    trackStyle,\n    handleStyle,\n    railStyle,\n    dotStyle,\n    activeDotStyle,\n\n    // Decorations\n    marks,\n    dots,\n\n    // Components\n    handleRender,\n\n    // Accessibility\n    tabIndex = 0,\n    ariaLabelForHandle,\n    ariaLabelledByForHandle,\n    ariaValueTextFormatterForHandle,\n  } = props;\n  const handlesRef = React.useRef<HandlesRef>();\n  const containerRef = React.useRef<HTMLDivElement>();\n\n  const direction: Direction = React.useMemo(() => {\n    if (vertical) {\n      return reverse ? 'ttb' : 'btt';\n    }\n    return reverse ? 'rtl' : 'ltr';\n  }, [reverse, vertical]);\n\n  // ============================ Range =============================\n  const mergedMin = React.useMemo(() => (isFinite(min) ? min : 0), [min]);\n  const mergedMax = React.useMemo(() => (isFinite(max) ? max : 100), [max]);\n\n  // ============================= Step =============================\n  const mergedStep = React.useMemo(() => (step !== null && step <= 0 ? 1 : step), [step]);\n\n  // ============================= Push =============================\n  const mergedPush = React.useMemo(() => {\n    if (pushable === true) {\n      return mergedStep;\n    }\n\n    return pushable >= 0 ? pushable : false;\n  }, [pushable, mergedStep]);\n\n  // ============================ Marks =============================\n  const markList = React.useMemo<InternalMarkObj[]>(() => {\n    const keys = Object.keys(marks || {});\n\n    return keys\n      .map((key) => {\n        const mark = marks[key];\n        const markObj: InternalMarkObj = {\n          value: Number(key),\n        };\n\n        if (\n          mark &&\n          typeof mark === 'object' &&\n          !React.isValidElement(mark) &&\n          ('label' in mark || 'style' in mark)\n        ) {\n          markObj.style = mark.style;\n          markObj.label = mark.label;\n        } else {\n          markObj.label = mark;\n        }\n\n        return markObj;\n      })\n      .filter(({ label }) => label || typeof label === 'number')\n      .sort((a, b) => a.value - b.value);\n  }, [marks]);\n\n  // ============================ Format ============================\n  const [formatValue, offsetValues] = useOffset(\n    mergedMin,\n    mergedMax,\n    mergedStep,\n    markList,\n    allowCross,\n    mergedPush,\n  );\n\n  // ============================ Values ============================\n  const [mergedValue, setValue] = useMergedState<number | number[], number[]>(defaultValue, {\n    value,\n  });\n\n  const rawValues = React.useMemo(() => {\n    const valueList =\n      mergedValue === null || mergedValue === undefined\n        ? []\n        : Array.isArray(mergedValue)\n        ? mergedValue\n        : [mergedValue];\n\n    const [val0 = mergedMin] = valueList;\n    let returnValues = mergedValue === null ? [] : [val0];\n\n    // Format as range\n    if (range) {\n      returnValues = [...valueList];\n\n      // When count provided or value is `undefined`, we fill values\n      if (count || mergedValue === undefined) {\n        const pointCount = count >= 0 ? count + 1 : 2;\n        returnValues = returnValues.slice(0, pointCount);\n\n        // Fill with count\n        while (returnValues.length < pointCount) {\n          returnValues.push(returnValues[returnValues.length - 1] ?? mergedMin);\n        }\n      }\n      returnValues.sort((a, b) => a - b);\n    }\n\n    // Align in range\n    returnValues.forEach((val, index) => {\n      returnValues[index] = formatValue(val);\n    });\n\n    return returnValues;\n  }, [mergedValue, range, mergedMin, count, formatValue]);\n\n  // =========================== onChange ===========================\n  const rawValuesRef = React.useRef(rawValues);\n  rawValuesRef.current = rawValues;\n\n  const getTriggerValue = (triggerValues: number[]) => (range ? triggerValues : triggerValues[0]);\n\n  const triggerChange = (nextValues: number[]) => {\n    // Order first\n    const cloneNextValues = [...nextValues].sort((a, b) => a - b);\n\n    // Trigger event if needed\n    if (onChange && !isEqual(cloneNextValues, rawValuesRef.current, true)) {\n      onChange(getTriggerValue(cloneNextValues));\n    }\n\n    // We set this later since it will re-render component immediately\n    setValue(cloneNextValues);\n  };\n\n  const changeToCloseValue = (newValue: number) => {\n    if (!disabled) {\n      let valueIndex = 0;\n      let valueDist = mergedMax - mergedMin;\n\n      if (!disableds.includes(true)) { \n        rawValues.forEach((val, index) => {\n        const dist = Math.abs(newValue - val);\n        if (dist <= valueDist) {\n          valueDist = dist;\n          valueIndex = index;\n        }\n        });\n      }\n\n      \n\n      // Create new values\n      const cloneNextValues = [...rawValues];\n\n      cloneNextValues[valueIndex] = newValue;\n\n      // Fill value to match default 2\n      if (range && !rawValues.length && count === undefined) {\n        cloneNextValues.push(newValue);\n      }\n\n      onBeforeChange?.(getTriggerValue(cloneNextValues));\n      triggerChange(cloneNextValues);\n      onAfterChange?.(getTriggerValue(cloneNextValues));\n    }\n  };\n\n  // ============================ Click =============================\n  const onSliderMouseDown: React.MouseEventHandler<HTMLDivElement> = (e) => {\n    e.preventDefault();\n\n    const { width, height, left, top, bottom, right } =\n      containerRef.current.getBoundingClientRect();\n    const { clientX, clientY } = e;\n\n    let percent: number;\n    switch (direction) {\n      case 'btt':\n        percent = (bottom - clientY) / height;\n        break;\n\n      case 'ttb':\n        percent = (clientY - top) / height;\n        break;\n\n      case 'rtl':\n        percent = (right - clientX) / width;\n        break;\n\n      default:\n        percent = (clientX - left) / width;\n    }\n\n    const nextValue = mergedMin + percent * (mergedMax - mergedMin);\n    changeToCloseValue(formatValue(nextValue));\n  };\n\n  // =========================== Keyboard ===========================\n  const [keyboardValue, setKeyboardValue] = React.useState<number>(null);\n\n  const onHandleOffsetChange = (offset: number | 'min' | 'max', valueIndex: number) => {\n    if (!disabled) {\n      const next = offsetValues(rawValues, offset, valueIndex);\n\n      onBeforeChange?.(getTriggerValue(rawValues));\n      triggerChange(next.values);\n      onAfterChange?.(getTriggerValue(next.values));\n\n      setKeyboardValue(next.value);\n    }\n  };\n\n  React.useEffect(() => {\n    if (keyboardValue !== null) {\n      const valueIndex = rawValues.indexOf(keyboardValue);\n      if (valueIndex >= 0) {\n        handlesRef.current.focus(valueIndex);\n      }\n    }\n\n    setKeyboardValue(null);\n  }, [keyboardValue]);\n\n  // ============================= Drag =============================\n  const mergedDraggableTrack = React.useMemo(() => {\n    if (draggableTrack && mergedStep === null) {\n      if (process.env.NODE_ENV !== 'production') {\n        warning(false, '`draggableTrack` is not supported when `step` is `null`.');\n      }\n      return false;\n    }\n    return draggableTrack;\n  }, [draggableTrack, mergedStep]);\n\n  const finishChange = () => {\n    onAfterChange?.(getTriggerValue(rawValuesRef.current));\n  };\n\n  const [draggingIndex, draggingValue, cacheValues, onStartDrag, beginDraggingIndex] = useDrag(\n    containerRef,\n    direction,\n    rawValues,\n    mergedMin,\n    mergedMax,\n    formatValue,\n    triggerChange,\n    finishChange,\n    offsetValues,\n    allowCross,\n  );\n\n  const onStartMove: OnStartMove = (e, valueIndex) => {\n    onStartDrag(e, valueIndex);\n\n    onBeforeChange?.(getTriggerValue(rawValuesRef.current));\n  };\n\n  // Auto focus for updated handle\n  const dragging = draggingIndex !== -1;\n  React.useEffect(() => {\n    if (!dragging) {\n      const valueIndex = rawValues.lastIndexOf(draggingValue);\n      handlesRef.current.focus(valueIndex);\n    }\n  }, [dragging]);\n\n  // =========================== Included ===========================\n  const sortedCacheValues = React.useMemo(\n    () => [...cacheValues].sort((a, b) => a - b),\n    [cacheValues],\n  );\n\n  // Provide a range values with included [min, max]\n  // Used for Track, Mark & Dot\n  const [includedStart, includedEnd] = React.useMemo(() => {\n    if (!range) {\n      return [mergedMin, sortedCacheValues[0]];\n    }\n\n    return [sortedCacheValues[0], sortedCacheValues[sortedCacheValues.length - 1]];\n  }, [sortedCacheValues, range, mergedMin]);\n\n  // ============================= Refs =============================\n  React.useImperativeHandle(ref, () => ({\n    focus: () => {\n      handlesRef.current.focus(0);\n    },\n    blur: () => {\n      const { activeElement } = document;\n      if (containerRef.current.contains(activeElement)) {\n        (activeElement as HTMLElement)?.blur();\n      }\n    },\n  }));\n\n  // ========================== Auto Focus ==========================\n  React.useEffect(() => {\n    if (autoFocus) {\n      handlesRef.current.focus(0);\n    }\n  }, []);\n\n  // =========================== Context ============================\n  const context = React.useMemo<SliderContextProps>(\n    () => ({\n      min: mergedMin,\n      max: mergedMax,\n      direction,\n      disabled,\n      keyboard,\n      step: mergedStep,\n      included,\n      includedStart,\n      includedEnd,\n      range,\n      tabIndex,\n      ariaLabelForHandle,\n      ariaLabelledByForHandle,\n      ariaValueTextFormatterForHandle,\n    }),\n    [\n      mergedMin,\n      mergedMax,\n      direction,\n      disabled,\n      keyboard,\n      mergedStep,\n      included,\n      includedStart,\n      includedEnd,\n      range,\n      tabIndex,\n      ariaLabelForHandle,\n      ariaLabelledByForHandle,\n      ariaValueTextFormatterForHandle,\n    ],\n  );\n\n  // ============================ Render ============================\n  return (\n    <SliderContext.Provider value={context}>\n      <div\n        ref={containerRef}\n        className={classNames(prefixCls, className, {\n          [`${prefixCls}-disabled`]: disabled,\n          [`${prefixCls}-vertical`]: vertical,\n          [`${prefixCls}-horizontal`]: !vertical,\n          [`${prefixCls}-with-marks`]: markList.length,\n        })}\n        style={style}\n        onMouseDown={onSliderMouseDown}\n      >\n        <div className={`${prefixCls}-rail`} style={railStyle} />\n\n        <Tracks\n          prefixCls={prefixCls}\n          style={trackStyle}\n          values={sortedCacheValues}\n          startPoint={startPoint}\n          onStartMove={mergedDraggableTrack ? onStartMove : null}\n        />\n\n        <Steps\n          prefixCls={prefixCls}\n          marks={markList}\n          dots={dots}\n          style={dotStyle}\n          activeStyle={activeDotStyle}\n        />\n\n        <Handles\n          ref={handlesRef}\n          prefixCls={prefixCls}\n          style={handleStyle}\n          values={cacheValues}\n          draggingIndex={draggingIndex}\n          beginDraggingIndex={beginDraggingIndex}\n          onStartMove={onStartMove}\n          onOffsetChange={onHandleOffsetChange}\n          onFocus={onFocus}\n          onBlur={onBlur}\n          handleRender={handleRender}\n          disableds={disableds}\n        />\n\n        <Marks prefixCls={prefixCls} marks={markList} onClick={changeToCloseValue} />\n      </div>\n    </SliderContext.Provider>\n  );\n});\n\nif (process.env.NODE_ENV !== 'production') {\n  Slider.displayName = 'Slider';\n}\n\nexport default Slider;\n"
        }
    ]
}